#!/usr/bin/env python3
import os, sys, json, argparse, shlex, subprocess, re
import urllib.request
import urllib.error

RESET = "\033[0m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
CYAN = "\033[96m"

APP_NAME = "hawk"
HISTORY_FILE = os.path.expanduser("~/.hawk_history")

def copy_to_clipboard(text: str):
    p = subprocess.Popen(["pbcopy"], stdin=subprocess.PIPE)
    p.communicate(input=text.encode("utf-8"))

def run_shell(cmd: str):
    subprocess.run(cmd, shell=True, check=False)

def save_history(cmd: str):
    with open(HISTORY_FILE, "a") as f:
        f.write(cmd.strip() + "\n")

def load_history(n: int = None):
    if not os.path.exists(HISTORY_FILE):
        return []
    with open(HISTORY_FILE, "r") as f:
        lines = [line.strip() for line in f if line.strip()]
    if n:
        return lines[-n:]
    return lines

def search_history(term: str):
    history = load_history()
    return [cmd for cmd in history if term.lower() in cmd.lower()]

def print_help():
    help_text = f"""
{CYAN}‚ú® Welcome to HAWK ‚ú®{RESET}
Natural Language ‚Üí awk command generator

Usage:
  hawk "<prompt>"            Generate command, copy to clipboard
  hawk --run "<prompt>"      Generate and run the command directly
  hawk --dry "<prompt>"      Generate and only show the command
  hawk --explain "<prompt>"  Generate and copy + show explanation
  hawk history [N]           Show the last N commands (default 10)
  hawk history --search STR  Search history for matching commands
  hawk --1                   Copy the last command to clipboard
  hawk --2                   Copy the second last command, etc.
  hawk --teach "<awk cmd>"   Explain an awk command in plain English
  hawk --interactive         Interactive REPL mode
  hawk --file FILE.txt       Batch mode: process prompts from a file

Examples:
  hawk "sum the last column in data.csv"
  hawk --run "unique values in second column of file.csv"
  hawk history 20
  hawk history --search sum
  hawk --teach "awk -F, '{{sum+=$3}} END {{print sum}}' file.csv"
"""
    print(help_text)

def generate_with_ollama(nl: str, model="qwen2.5-coder:3b") -> dict:
    sys_prompt = (
        "You are an awk command generator.\n"
        "Your ONLY valid output is strict JSON in the form: {\"cmd\": \"...\", \"explain\": \"...\"}.\n"
        "Do not output anything else.\n"
        "\n"
        "Rules for 'cmd':\n"
        "1. The command MUST start with 'awk'. You may append safe Unix pipes (sort, uniq, head, tail, cut).\n"
        "2. When generating distinct/unique values, always prefer 'sort -u' (never 'sort | uniq').\n"
        "3. Always assume input is CSV unless the user explicitly specifies otherwise. Use -F, by default. "
        "If TSV is specified, use -F'\\t'. If space-delimited is explicitly requested, omit -F.\n"
        "4. If no file is given, default to 'file.csv'.\n"
        "5. Do not wrap commands in quotes or add comments.\n"
        "6. The 'explain' must be a one-line, plain-English summary that matches the command exactly.\n"
        "7. Never hallucinate tools other than awk + basic pipes. No sed, grep, or jq.\n"
        "8. If the user specifies a column by NAME (e.g., 'Name'), you must not guess its index. "
        "Default to column $2 only if unclear, but explicitly state this assumption in the 'explain'.\n"
    )
    payload = {
        "model": model,
        "prompt": f"{sys_prompt}\nUser: {nl}\nAssistant:",
        "stream": False,
        "options": {"temperature": 0}
    }
    try:
        req = urllib.request.Request(
            "http://localhost:11434/api/generate",
            data=json.dumps(payload).encode("utf-8"),
            headers={"Content-Type": "application/json"},
            method="POST"
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read().decode("utf-8"))
        raw = data.get("response", "").strip()
        match = re.search(r"\{.*\}", raw, re.DOTALL)
        if not match:
            raise ValueError(f"Ollama did not return JSON: {raw}")
        obj = json.loads(match.group(0))
        return {"cmd": obj.get("cmd", "").strip(),
                "explain": obj.get("explain", "").strip()}
    except Exception as e:
        print(f"{RED}‚ö†Ô∏è  Ollama is not running or failed to respond.{RESET}")
        print(f"{RED}   Start it with: ollama serve   (or check LaunchAgent).{RESET}")
        sys.exit(1)

def explain_with_ollama(awk_cmd: str, model="qwen2.5-coder:3b") -> str:
    prompt = f"Explain in plain English what this awk command does:\n{awk_cmd}"
    payload = {"model": model, "prompt": prompt, "stream": False}
    try:
        req = urllib.request.Request(
            "http://localhost:11434/api/generate",
            data=json.dumps(payload).encode("utf-8"),
            headers={"Content-Type": "application/json"},
            method="POST"
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read().decode("utf-8"))
        return data.get("response", "").strip()
    except Exception as e:
        print("‚ö†Ô∏è Ollama not available for teach mode.")
        sys.exit(1)

def main():
    if len(sys.argv) == 1:
        print_help()
        sys.exit(0)

    # Recall commands like: hawk --1
    if re.match(r"--\d+$", sys.argv[1]):
        idx = int(sys.argv[1][2:])
        history = load_history()
        if idx <= 0 or idx > len(history):
            print(f"No such command in history: --{idx}")
            sys.exit(1)
        cmd = history[-idx]
        copy_to_clipboard(cmd)
        print(f"{GREEN}Copied command #{idx} from history:\n{cmd}{RESET}")
        sys.exit(0)

    # History handling
    if sys.argv[1] == "history":
        if len(sys.argv) > 2 and sys.argv[2] == "--search":
            term = " ".join(sys.argv[3:])
            results = search_history(term)
            if results:
                print(f"{CYAN}" + "\n".join(results) + f"{RESET}")
            else:
                print("No matches found.")
        else:
            n = int(sys.argv[2]) if len(sys.argv) > 2 else 10
            history = load_history(n)
            for cmd in history:
                print(cmd)
        sys.exit(0)

    # Teach mode
    if sys.argv[1] == "--teach":
        awk_cmd = " ".join(sys.argv[2:])
        explanation = explain_with_ollama(awk_cmd)
        print(f"{YELLOW}üìñ Explanation:{RESET}\n", explanation)
        sys.exit(0)

    # Interactive mode
    if sys.argv[1] == "--interactive":
        print(f"{CYAN}Entering HAWK interactive mode. Type 'exit' to quit.{RESET}")
        while True:
            user_in = input("hawk> ").strip()
            if user_in.lower() in {"exit", "quit"}:
                break
            result = generate_with_ollama(user_in)
            cmd = result["cmd"].strip()
            print(f"{GREEN}Generated:{RESET} {cmd}")
            save_history(cmd)
        sys.exit(0)

    # Batch mode
    if sys.argv[1] == "--file":
        file_path = sys.argv[2]
        with open(file_path, "r") as f:
            prompts = [line.strip() for line in f if line.strip()]
        for p in prompts:
            result = generate_with_ollama(p)
            cmd = result["cmd"].strip()
            print(f"{YELLOW}{p}{RESET} ‚Üí {GREEN}{cmd}{RESET}")
            save_history(cmd)
        sys.exit(0)

    # Normal generation
    parser = argparse.ArgumentParser(prog=APP_NAME, description="Natural-language ‚Üí awk command.")
    parser.add_argument("--run", action="store_true", help="Execute the generated command directly.")
    parser.add_argument("--explain", action="store_true", help="Print explanation too.")
    parser.add_argument("--dry", action="store_true", help="Show command only (no copy/run).")
    parser.add_argument("prompt", nargs="+", help="Natural language prompt.")
    args = parser.parse_args()

    nl_prompt = " ".join(args.prompt)
    result = generate_with_ollama(nl_prompt)
    cmd = result["cmd"].strip()

    save_history(cmd)

    if args.dry:
        print(f"{GREEN}Generated:{RESET} {cmd}")
        if args.explain:
            print(f"{CYAN}‚Äî {result.get('explain', '')}{RESET}")
    elif args.run:
        print(f"{YELLOW}‚ñ∂ Running: {cmd}{RESET}")
        run_shell(cmd)
    else:
        copy_to_clipboard(cmd)
        print(f"{GREEN}Command copied to clipboard successfully.{RESET}")
        if args.explain:
            print(f"{CYAN}‚Äî {result.get('explain', '')}{RESET}")

if __name__ == "__main__":
    main()